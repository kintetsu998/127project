{
  "name": "pg-promise",
  "version": "1.11.0",
  "description": "PostgreSQL via promises",
  "main": "lib/index.js",
  "scripts": {
    "test": "jasmine-node test",
    "doc": "./node_modules/.bin/jsdoc -c jsDoc.json",
    "coverage": "istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test",
    "travis": "istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test --captureExceptions && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage"
  },
  "homepage": "https://github.com/vitaly-t/pg-promise",
  "repository": {
    "type": "git",
    "url": "https://github.com/vitaly-t/pg-promise.git"
  },
  "bugs": {
    "url": "https://github.com/vitaly-t/pg-promise/issues",
    "email": "vitaly.tomilov@gmail.com"
  },
  "keywords": [
    "pg",
    "pg-promise",
    "postgres",
    "transaction"
  ],
  "author": {
    "name": "Vitaly Tomilov",
    "email": "vitaly.tomilov@gmail.com"
  },
  "license": "MIT",
  "engines": {
    "node": ">=0.10",
    "npm": ">=1.4"
  },
  "dependencies": {
    "pg": "4.x",
    "promise": "7.x"
  },
  "devDependencies": {
    "JSONStream": "1.x",
    "bluebird": "2.x",
    "coveralls": "2.x",
    "grunt": "0.4.x",
    "grunt-jsdoc-to-markdown": "1.x",
    "istanbul": "0.3",
    "jasmine-node": "1.x",
    "jsdoc": "3.x",
    "pg-query-stream": "0.7"
  },
  "readme": "pg-promise\r\n===========\r\n\r\nComplete access layer to [node-postgres] via [Promises/A+].\r\n\r\n[![Build Status](https://travis-ci.org/vitaly-t/pg-promise.svg?branch=master)](https://travis-ci.org/vitaly-t/pg-promise)\r\n[![Coverage Status](https://coveralls.io/repos/vitaly-t/pg-promise/badge.svg?branch=master)](https://coveralls.io/r/vitaly-t/pg-promise?branch=master)\r\n\r\n---\r\n<a href=\"https://promisesaplus.com/\"><img align=\"right\" width=\"190\" height=\"190\" src=\"http://s8.postimg.org/k7dtue8lx/pg_promise.jpg\"></a>\r\n\r\n* Supporting [Promise], [Bluebird], [When], [Q], etc.\r\n* Transactions, functions, flexible query formatting;\r\n* Automatic database connections;\r\n* Strict query result filters.\r\n\r\n---\r\n\r\n* [About](#about)\r\n* [Installing](#installing)\r\n  - [Documentation](#documentation)\r\n* [Testing](#testing)\r\n* [Getting Started](#getting-started)\r\n  - [Initializing](#initializing)\r\n  - [Connecting](#connecting)\r\n  - [Learn by Example](https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example)  \r\n* [Usage](#usage)\r\n  - [Queries and Parameters](#queries-and-parameters)\r\n    - [Query Result Mask](#query-result-mask)    \r\n  - [Named Parameters](#named-parameters)\r\n  - [Conversion Helpers](#conversion-helpers)\r\n  - [Custom Type Formatting](#custom-type-formatting)  \r\n    - [Raw Custom Types](#raw-custom-types)\r\n  - [Connections](#connections)  \r\n    - [Detached Connections](#detached-connections)\r\n    - [Shared Connections](#shared-connections)\r\n    - [Tasks](#tasks)    \r\n  - [Transactions](#transactions)\r\n    - [Detached Transactions](#detached-transactions)\r\n    - [Shared-connection Transactions](#shared-connection-transactions)\r\n    - [Nested Transactions](#nested-transactions)\r\n    - [Transactions with SAVEPOINT](#transactions-with-savepoint)\r\n    - [Synchronous Transactions](#synchronous-transactions)    \r\n    - [Sequence Benchmark](#sequence-benchmark) \r\n* [Advanced](#advanced)\r\n  - [Initialization Options](#initialization-options)\r\n    - [pgFormatting](#pgformatting)\r\n    - [promiseLib](#promiselib)\r\n    - [connect](#connect)\r\n    - [query](#query)\r\n    - [error](#error)\r\n    - [task](#task)    \r\n    - [transact](#transact)\r\n    - [extend](#extend)\r\n    - [noLocking](#nolocking)    \r\n  - [Library de-initialization](#library-de-initialization)\r\n* [History](#history)\r\n* [License](#license)\r\n\r\n---\r\n\r\n# About\r\n\r\nBuilt on top of [node-postgres] and its connection pool, this library translates their callback interface into one based on [Promises/A+],\r\nwhile extending the protocol to a higher level, with automated connections and transactions management.\r\n\r\nIn addition, the library provides:\r\n\r\n* its own, more flexible query formatting;\r\n* event reporting for connectivity, errors, queries and transactions;\r\n* declarative approach to controlling query results;\r\n* support for all popular promise libraries.\r\n\r\n# Installing\r\n```\r\n$ npm install pg-promise\r\n```\r\n\r\n### Documentation\r\nIn addition to the online documentation, there is in-line API documentation,\r\nbased on [jsDoc](https://github.com/jsdoc3/jsdoc).\r\n\r\nIn order to generate it, you need to do the following:\r\n * `$ cd node_modules/pg-promise`\r\n * `$ npm install` - to install DEV dependencies of the library;\r\n * `$ npm run doc` - will generate the documentation;\r\n * open `out/index.html` in a web browser.\r\n\r\nAlternatively, you can use its converted version of the [API], which doesn't look as good though,\r\nand is a work in progress.\r\n\r\n# Testing\r\n* Install the library's dependencies:\r\n```\r\n$ npm install\r\n```\r\n* Make sure all tests can connect to your local test database, using the connection details in\r\n[test/db/header.js](https://github.com/vitaly-t/pg-promise/blob/master/test/db/header.js).\r\nEither set up your test database accordingly or change the connection details in that file.\r\n\r\n* Initialize the database with some test data:\r\n```\r\n$ node test/db/init.js\r\n```\r\n* To run all tests:\r\n```\r\n$ npm test\r\n```\r\n* To run all tests with coverage:\r\n```\r\n$ npm run coverage\r\n```\r\n\r\n# Getting Started\r\n\r\n## Initializing\r\n\r\n```javascript\r\n// Loading and initializing the library:\r\nvar pgp = require('pg-promise')(/*options*/);\r\n```\r\nYou can pass `options` parameter when initializing the library (see chapter [Initialization Options](#advanced)).\r\n\r\n## Connecting\r\n\r\nUse one of the two ways to specify database connection details:\r\n* Configuration Object:\r\n```javascript\r\nvar cn = {\r\n    host: 'localhost', // server name or IP address;\r\n    port: 5432,\r\n    database: 'my_db_name',\r\n    user: 'user_name',\r\n    password: 'user_password'\r\n};\r\n```\r\n* Connection String:\r\n```javascript\r\nvar cn = \"postgres://username:password@host:port/database\";\r\n```\r\n\r\nThis library doesn't use any of the connection's details, it simply passes them on to [PG] when opening a connection.\r\nFor more details see pg connection parameters in [WiKi](https://github.com/brianc/node-postgres/wiki/pg#parameters) and\r\n[implementation](https://github.com/brianc/node-postgres/blob/master/lib/connection-parameters.js).\r\n\r\nCreate a new database instance from the connection details:\r\n```javascript\r\nvar db = pgp(cn);\r\n```\r\nThere can be multiple database objects in the application for different connections.\r\n\r\nTo get started quickly, see our [Learn by Example](https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example) tutorial. \r\n\r\n# Usage\r\n\r\n## Queries and Parameters\r\n\r\nEvery connection context of the library shares the same query protocol, starting with generic method `query`,\r\ndefined as shown below:\r\n\r\n```javascript\r\nfunction query(query, values, qrm);\r\n```\r\n* `query` (required) - a string with support for three types of formatting, depending on the `values` passed:\r\n   - format `$1` (single variable), if `values` is of type `string`, `boolean`, `number`, `Date`, `function` or `null`;\r\n   - format `$1, $2, etc..`, if `values` is an array;\r\n   - format `$*propName*`, if `values` is an object (not `null` and not `Date`), where `*` is any of the supported open-close pairs: `{}`, `()`, `<>`, `[]`, `//`;\r\n* `values` (optional) - value/array/object to replace the variables in the query;\r\n* `qrm` - (optional) *Query Result Mask*, as explained below. When not passed, it defaults to `queryResult.any`.\r\n\r\nWhen a value/property inside array/object is an array, it is treated as a [PostgreSQL Array Type](http://www.postgresql.org/docs/9.4/static/arrays.html),\r\nconverted into the array constructor format of `array[]`, the same as calling method `as.array()`.\r\n\r\nExamples:\r\n```javascript\r\nconsole.log(pgp.as.array([[1, 2, 3], [4, 5, null]]));\r\n// will print: array[[1,2,3],[4,5,null]]\r\n\r\nconsole.log(pgp.as.array([['one', 'two'], [undefined, 'four']]));\r\n// will print: array[['one','two'],[null,'four']]\r\n\r\nconsole.log(pgp.as.array([[1, 2], ['three', 'four']]));\r\n// will print: array[[1,2],['three','four']],\r\n// but executing it within a query will throw an error\r\n// due to heterogeneous data type in the array.\r\n```\r\n\r\nWhen a value/property inside array/object is of type `object` (except for `null` and `Date`), it is automatically\r\nserialized into JSON, the same as calling method `as.json()`, except the latter would convert anything to JSON.\r\n\r\nRaw-text values can be injected by appending the variable name with symbol `^`:\r\n`$1^, $2^, etc...`, `$*varName^*`, where `*` is any of the supported open-close pairs: `{}`, `()`, `<>`, `[]`, `//`\r\n\r\nRaw text is injected without any pre-processing, which means:\r\n* No replacing each single-quote symbol `'` with two;\r\n* No wrapping text into single quotes.\r\n\r\nThis is to allow for special-case variable formatting, like in the following examples:\r\n\r\n```javascript\r\n// injecting \"John\" name without quotes:\r\nquery(\"...WHERE name LIKE '%$1^%'\", \"John\");\r\n\r\n// injecting value of property 'name' without quotes:\r\nquery(\"...WHERE name LIKE '%${name^}%'\", {name: \"John\"});\r\n\r\n// injecting a CSV-formatted text without quotes:\r\nquery(\"...WHERE id IN($1^)\", pgp.as.csv([1,2,3,4])); \r\n```\r\n\r\n### Query Result Mask\r\n\r\nIn order to eliminate the chances of unexpected query results and thus make the code more robust,\r\nmethod `query` uses parameter `qrm` (Query Result Mask):\r\n```javascript\r\n///////////////////////////////////////////////////////\r\n// Query Result Mask flags;\r\n//\r\n// Any combination is supported, except for one + many.\r\nqueryResult = {\r\n    one: 1,     // single-row result is expected;\r\n    many: 2,    // multi-row result is expected;\r\n    none: 4,    // no rows expected;\r\n    any: 6      // (default) = many|none = any result.\r\n};\r\n```\r\n\r\nIn the following generic-query example we indicate that the call can return anything:\r\n```javascript\r\ndb.query(\"select * from users\");\r\n```\r\nwhich is equivalent to making one of the following calls:\r\n```javascript\r\ndb.query(\"select * from users\", undefined, queryResult.many | queryResult.none);\r\ndb.query(\"select * from users\", undefined, queryResult.any);\r\ndb.manyOrNone(\"select * from users\");\r\ndb.any(\"select * from users\");\r\n```\r\n\r\nThis usage pattern is facilitated through result-specific methods that can be used instead of the generic query:\r\n```javascript\r\ndb.many(query, values); // expects one or more rows\r\ndb.one(query, values); // expects a single row\r\ndb.none(query, values); // expects no rows\r\ndb.any(query, values); // expects anything, same as `manyOrNone`\r\ndb.oneOrNone(query, values); // expects 1 or 0 rows\r\ndb.manyOrNone(query, values); // expects anything, same as `any`\r\n```\r\n\r\nThere is however one specific method `queryRaw(query, values)`, with aliases `raw` and `result` to instruct the library\r\nthat any result verification is to be bypassed, and instead it must resolve with the original\r\n[Result](https://github.com/brianc/node-postgres/blob/master/lib/result.js#L6) object passed from the [PG] library.\r\n\r\nYou can also add your own methods and properties to this protocol via the [extend](#extend) event.  \r\n\r\nEach query function resolves its **data** object according to the `qrm` that was used:\r\n\r\n* `none` - **data** is `undefined`. If the query returns any kind of data, it is rejected.\r\n* `one` - **data** is a single object. If the query returns no data or more than one row of data, it is rejected.\r\n* `many` - **data** is an array of objects. If the query returns no rows, it is rejected.\r\n* `one`|`none` - **data** is `null`, if no data was returned; or a single object, if there was one row of data returned. If the query returns more than one row of data,\r\nthe query is rejected.\r\n* `many`|`none` - **data** is an array of objects. When no rows are returned, **data** is an empty array.\r\n\r\nIf you try to specify `one`|`many` in the same query, such query will be rejected without executing it, telling you that such mask is invalid.\r\n\r\nIf `qrm` is not specified when calling generic `query` method, it is assumed to be `many`|`none` = `any`, i.e. any kind of data expected.\r\n\r\n> This is all about writing robust code, when the client specifies what kind of data it is ready to handle on the declarative level,\r\nleaving the burden of all extra checks to the library.\r\n\r\n## Named Parameters\r\n\r\nThe library supports named parameters in query formatting, with the syntax of `$*propName*`,\r\nwhere `*` is any of the following open-close pairs: `{}`, `()`, `<>`, `[]`, `//`\r\n\r\n```javascript\r\ndb.query(\"select * from users where name=${name} and active=$/active/\", {\r\n    name: 'John',\r\n    active: true\r\n});\r\n```\r\n\r\nThe same goes for all types of query methods as well as method `as.format(query, values)`, where `values`\r\nnow can also be an object whose properties can be referred to by name from within the query.\r\n\r\nA valid property name consists of any combination of letters, digits, underscores or `$`, and they are case-sensitive.\r\nLeading and trailing spaces around property names are ignored.\r\n\r\nIt is important to know that while property values `null` and `undefined` are both formatted as `null`,\r\nan error is thrown when the property doesn't exist at all.\r\n\r\n## Functions and Procedures\r\n\r\nIn PostgreSQL stored procedures are just functions that usually do not return anything.\r\n\r\nSuppose we want to call function **findAudit** to find audit records by **user id** and maximum timestamp.\r\nWe can make such call as shown below:\r\n\r\n```javascript\r\ndb.func('findAudit', [123, new Date()])\r\n    .then(function(data){\r\n        console.log(data); // printing the data returned\r\n    }, function(reason){\r\n        console.log(reason); // printing the reason why the call was rejected\r\n    });\r\n```\r\n\r\nWe passed it **user id** = 123, plus current Date/Time as the timestamp. We assume that the function signature matches\r\nthe parameters that we passed. All values passed are serialized automatically to comply with PostgreSQL type formats.\r\n\r\nMethod `func` accepts optional third parameter - `qrm` (Query Result Mask), the same as method `query`.\r\n\r\nAnd when you are not expecting any return results, call `db.proc` instead. Both methods return a [Promise] object,\r\nbut `db.proc` doesn't take a `qrm` parameter, always assuming it is `one`|`none`.\r\n\r\nSummary for supporting procedures and functions:\r\n\r\n```javascript\r\ndb.func(query, values, qrm); // expects the result according to `qrm`\r\ndb.proc(query, values); // calls db.func(query, values, queryResult.one | queryResult.none)\r\n```\r\n\r\n## Conversion Helpers\r\n\r\nThe library provides several helper functions to convert javascript types into their proper PostgreSQL presentation that can be passed\r\ndirectly into queries or functions as parameters. All of such helper functions are located within namespace `pgp.as`, and each function\r\nreturns a formatted string when successful or throws an error when it fails.\r\n\r\n```javascript\r\npgp.as.bool(value); // converts value into PostgreSQL boolean presentation;\r\n\r\npgp.as.number(value);\r\n                    // converts value into PostgreSQL number presentation,\r\n                    // with support for NaN, +Infinity and -Infinity;\r\n\r\npgp.as.text(value, raw);\r\n                    // converts value into PostgreSQL text presentation,\r\n                    // fixing single-quote symbols and wrapping the result\r\n                    // in quotes (unless flag 'raw' is set);\r\n\r\npgp.as.date(value, raw);\r\n                    // converts value into PostgreSQL date/time presentation,\r\n                    // wrapped in quotes (unless flag 'raw' is set);\r\n\r\npgp.as.json(value, raw);\r\n                    // converts any value into JSON (using JSON.stringify),\r\n                    // then fixes single-quote symbols and wraps it up in\r\n                    // single quotes (unless flag 'raw' is set);\r\n\r\npgp.as.array(value); // converts value-array into PostgreSQL Array Type constructor\r\n                     // string: array[]\r\n\r\npgp.as.csv(value);  // returns a CSV string with values formatted according\r\n                    // to their type, using the above methods;\r\n\r\npgp.as.func(func, raw, obj);\r\n                    // calls the function to get the actual value, and then\r\n                    // formats it according to the returned type + 'raw' flag;\r\n                    // obj - optional, 'this' context for the function. \r\n\r\npgp.as.format(query, values);\r\n            // replaces variables in the query with their 'values' as specified;\r\n            // 'values' can be a single value, an array or an object.\r\n```\r\n\r\nVersion 1.4.1 extended methods `bool`, `number`, `text`, `date`, `json`, `array`\r\nand `csv` to accept the value-parameter as a function to be called for resolving\r\nthe actual value.\r\n\r\nFor methods which take optional flag `raw` it is to indicate that the\r\nreturn text is to be without any pre-processing:\r\n* No replacing each single-quote symbol `'` with two;\r\n* No wrapping text into single quotes;\r\n* Throwing an error when the variable value is `null` or `undefined`.\r\n\r\nThis adheres to the query formatting, as well as method `as.format` when variable\r\nnames are appended with symbol `^`: `$1^, $2^, etc...` or `$*varName^*`, where `*`\r\nis any of the supported open-close pairs: `{}`, `()`, `<>`, `[]`, `//`\r\n\r\nAs none of these helpers are associated with any database, they can be used from anywhere.\r\n\r\nThere are some cases where you might want to use a combination of these methods instead\r\nof the implicit parameter formatting through query methods. For example, if you want to\r\ngenerate a filter string to be used where applicable, you might use a code like this:\r\n\r\n```javascript\r\nfunction createFilter(filter){\r\n    var cnd = []; // conditions;\r\n    if(filter.start){\r\n        // add start date condition;\r\n        cnd.push(pgp.as.format(\"start >= $1::date\", filter.start));\r\n    }\r\n    if(filter.end){\r\n        // add end date condition;\r\n        cnd.push(pgp.as.format(\"end <= $1::date\", filter.end));\r\n    }\r\n    if(filter.active !== undefined){\r\n        // add active flag;\r\n        cnd.push(pgp.as.format(\"active = $1\", filter.active));\r\n    }\r\n    if(filter.name){\r\n        // add name-like condition with a raw-text variable\r\n        // by appending '^' to its name;\r\n        cnd.push(pgp.format(\"name like '%$1^%'\", filter.name));\r\n    }\r\n    return cnd.join(\" and \"); // returning the complete filter string;\r\n}\r\n```\r\n\r\n## Custom Type Formatting\r\n\r\nVersion 1.9.3 added support for custom type formatting.\r\n\r\nWhen we pass `values` as a single parameter or inside an array, it is verified to be an object\r\nthat supports function `formatDBType`, as either its own or inherited. And if the function exists,\r\nits return result overrides both the actual value and the formatting syntax for parameter `query`.\r\n\r\nThis allows use of your own custom types as formatting parameters for the queries, as well as\r\noverriding formatting for standard object types, such as `Date` and `Array`.\r\n\r\n**Example: your own type formatting**\r\n```javascript\r\nfunction Money(m) {\r\n    this.amount = m;\r\n    this.formatDBType = function () {\r\n        // return a string with 2 decimal points;\r\n        return this.amount.toFixed(2);\r\n    }\r\n}\r\n```\r\n\r\n**Example: overriding standard types**\r\n```javascript\r\nDate.prototype.formatDBType = function () {\r\n    // format Date as a local timestamp;\r\n    return this.getTime();\r\n};\r\n```\r\n\r\nFunction `formatDBType` is allowed to return absolutely anything, including:\r\n* instance of another object that supports its own custom formatting;\r\n* instance of another object that doesn't have its own custom formatting;\r\n* another function, with recursion of any depth;\r\n\r\nPlease note that the return result from `formatDBType` may even affect the\r\nformatting syntax expected within parameter `query`, as explained below.\r\n\r\nIf you pass in `values` as an object that has function `formatDBType`,\r\nand that function returns an array, then your `query` is expected to use \r\n`$1, $2` as the formatting syntax.\r\n\r\nAnd if `formatDBType` in that case returns a custom-type object that doesn't support\r\ncustom formatting, then `query` will be expected to use `$*propName*` as the formatting syntax.\r\n\r\n### Raw Custom Types\r\n\r\nAdded in 1.9.5, this features allows overriding `raw` flag for the values returned\r\nfrom custom types.\r\n\r\nAny custom type or standard type that implements function `formatDBType` can now also set\r\nproperty `_rawDBType = true` to force raw variable formatting on the returned value.\r\n\r\nThis makes the custom type formatting ultimately flexible, as now there is no limitation\r\nas to how a custom type can format its value.\r\n\r\nFor example, some special types, like UUID, do not have natural presentation in JavaScript,\r\nso they have to be converted into text strings when passed into the query formatting.\r\nFor an array of UUID-s, for instance, you would have to explicitly cast the formatted value\r\nwith `::uuid[]` appended at the end of the variable.\r\n  \r\nNow you can implement your own presentation for UUID that does not require extra casting:\r\n\r\n```javascript  \r\nfunction UUID(value) {\r\n    this.uuid = value;\r\n    this._rawDBType = true; // force raw format on output;\r\n    this.formatDBType = function () {\r\n        // alternatively, you can set flag\r\n        // _rawDBType during this call:\r\n        // this._rawDBType = true;\r\n        return this.uuid;\r\n    };\r\n}\r\n``` \r\n  \r\nWhen you chain one custom-formatting type to return another one, please note that\r\nsetting `_rawDBType` on any level will set the flag for the entire chain.\r\n  \r\n## Connections\r\n\r\nThe library supports promise-chained queries on shared and detached connections.\r\nChoosing which one to use depends on the situation and personal preferences.\r\n\r\n### Detached Connections\r\n\r\nQueries in a detached promise chain maintain connection independently, they each acquire a connection from the pool,\r\nexecute the query and then release the connection back to the pool.\r\n```javascript\r\ndb.one(\"select * from users where id=$1\", 123) // find the user from id;\r\n    .then(function(data){\r\n        // find 'login' records for the user found:\r\n        return db.query(\"select * from audit where event=$1 and userId=$2\",\r\n            [\"login\", data.id]);\r\n    })\r\n    .then(function(data){\r\n        // display found audit records;\r\n        console.log(data);\r\n    }, function(reason){\r\n        console.log(reason); // display reason why the call failed;\r\n    })\r\n```\r\nIn a situation where a single request is to be made against the database, a detached chain is the only one that makes sense.\r\nAnd even if you intend to execute multiple queries in a chain, keep in mind that even though each will use its own connection,\r\nsuch will be used from a connection pool, so effectively you end up with the same connection, without any performance penalty.\r\n\r\n### Shared Connections\r\n\r\nA promise chain with a shared connection starts with `connect()`, which acquires a connection from the pool to be shared\r\nwith all the queries down the promise chain. The connection must be released back to the pool when no longer needed.\r\n\r\n```javascript\r\nvar sco; // shared connection object;\r\ndb.connect()\r\n    .then(function(obj) {\r\n        sco = obj; // save the connection object;\r\n        // find active users created before today:\r\n        return sco.query(\"select * from users where active=$1 and created < $2\",\r\n            [true, new Date()]);\r\n    })\r\n    .then(function(data) {\r\n        console.log(data); // display all the user details;\r\n    }, function(reason) {\r\n        console.log(reason); // display reason why the call failed;\r\n    })\r\n    .done(function() {\r\n        if(sco) {\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\nShared-connection chaining is when you want absolute control over the connection, either because you want to execute lots of queries in one go,\r\nor because you like squeezing every bit of performance out of your code. Other than that, the author hasn't seen any performance difference\r\nfrom the detached-connection chaining. And besides, any long sequence of queries normally resides inside a transaction, which always\r\nuses shared-connection chaining automatically.\r\n\r\n**UPDATE:** With [Tasks](#tasks) added below, shared connections become even easier to use.\r\n\r\n### Tasks\r\n\r\nVersion 1.9.0 introduced support for tasks, also replacing the engine for transactions, i.e.\r\na transaction is now just a special case of a task.\r\n\r\n```javascript\r\ndb.task(function (t) {\r\n    // t = this;\r\n    // execute a chain of queries and return a promise;\r\n})\r\n    .then(function (data) {\r\n        // success;\r\n    }, function (reason) {\r\n        // failed;\r\n    });\r\n```\r\n\r\nTasks and transactions work in the same way, except a task doesn't execute any of the transaction commands - `BEGIN`/`COMMIT`/`ROLLBACK`.\r\n\r\nThe purpose of tasks is simply to provide a shared connection context within the callback function to execute and return\r\na promise chain, and then automatically release the connection.\r\n\r\nIn other words, it is to simplify the use of [shared connections](#shared-connections), so instead of calling `connect` in the beginning\r\nand `done` in the end (if it was connected successfully), one can call `db.task` instead, execute all queries within\r\nthe callback and return the result.\r\n\r\nAs tasks and transactions share the same engine, they are considered equally important. Therefore, tasks have received\r\ntheir own [task event](#task) to be notified when a task is being executed. \r\n \r\n## Transactions\r\n\r\nTransactions can be executed within both shared and detached promise chains in the same way, performing the following actions:\r\n\r\n1. Acquires a new connection (detached chains only);\r\n2. Executes `BEGIN` command;\r\n3. Invokes your callback function with the connection object;\r\n4. Executes `COMMIT`, if the callback resolves, or `ROLLBACK`, if the callback rejects;\r\n5. Releases the connection (detached chains only);\r\n6. Resolves with the callback result, if success; rejects with the reason, if failed.\r\n\r\n### Detached Transactions\r\n\r\n```javascript\r\nvar promise = require('promise'); // or any other supported promise library;\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    // creating a sequence of transaction queries:\r\n    var q1 = this.none(\"update users set active=$1 where id=$2\", [true, 123]);\r\n    var q2 = this.one(\"insert into audit(entity, id) values($1, $2) returning id\",\r\n        ['users', 123]);\r\n\r\n    // returning a promise that determines a successful transaction:\r\n    return this.batch([q1, q2]); // all of the queries are to be resolved;\r\n\r\n}).then(function (data) {\r\n    console.log(data); // printing successful transaction output\r\n}, function (reason) {\r\n    console.log(reason); // printing the reason why the transaction was rejected\r\n});\r\n```\r\n\r\nA detached transaction acquires a connection and exposes object `t` to let all containing queries execute on the same connection.\r\n\r\n### Shared-connection Transactions\r\n\r\nWhen executing a transaction within a shared connection chain, parameter `t` represents the same connection as `sco` from opening a shared connection,\r\nso either one can be used inside such a transaction interchangeably.\r\n\r\n```javascript\r\nvar promise = require('promise'); // or any other supported promise library;\r\nvar sco; // shared connection object;\r\ndb.connect()\r\n    .then(function (obj) {\r\n        sco = obj;\r\n        return sco.oneOrNone(\"select * from users where active=$1 and id=$1\", [true, 123]);\r\n    })\r\n    .then(function (data) {\r\n        return sco.tx(function (t) {\r\n            // t = this;\r\n            // Since it is a transaction within a shared chain, it doesn't matter whether\r\n            // the two calls below use object `t` or `sco`, as they are exactly the same:\r\n            var q1 = t.none(\"update users set active=$1 where id=$2\", [false, data.id]);\r\n            var q2 = sco.one(\"insert into audit(entity, id) values($1, $2) returning id\",\r\n                ['users', 123]);\r\n\r\n            // returning a promise that determines a successful transaction:\r\n            return t.batch([q1, q2]); // all of the queries are to be resolved;\r\n        });\r\n    }, function (reason) {\r\n        console.log(reason); // printing the reason why the transaction was rejected;\r\n    })\r\n    .done(function () {\r\n        if (sco) {\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\nIf you need to execute just one transaction, the detached transaction pattern is all you need.\r\nBut even if you need to combine it with other queries in a detached chain, it will work the same.\r\nAs stated earlier, choosing a shared chain over a detached one is mostly a matter of special requirements\r\nand/or personal preference.\r\n\r\n### Nested Transactions\r\n\r\nSimilar to the shared-connection transactions, nested transactions automatically share the connection between all levels.\r\nThis library sets no limitation as to the depth (nesting levels) of transactions supported.\r\n\r\nExample:\r\n\r\n```javascript\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    var queries = [\r\n        this.none(\"drop table users;\"),\r\n        this.none(\"create table users(id serial not null, name text not null)\")\r\n    ];\r\n    for (var i = 1; i <= 100; i++) {\r\n        queries.push(this.none(\"insert into users(name) values($1)\", \"name-\" + i));\r\n    }\r\n    queries.push(\r\n        this.tx(function () {\r\n            return this.tx(function () {\r\n                return this.one(\"select count(*) from users\");\r\n            });\r\n        }));\r\n    return this.batch(queries);\r\n})\r\n    .then(function (data) {\r\n        console.log(data); // printing transaction result;\r\n    }, function (reason) {\r\n        console.log(reason); // printing why the transaction failed;\r\n    })\r\n```\r\n\r\nThings to note from the example above:\r\n* Sub-transactions do not declare a context parameter in their callback. It is not because\r\nthey don't receive one, they all do, but they don't care in such situation because of the shared connection\r\nchain that will result in the same `t` object as for the main callback, so they just reuse it from the parent,\r\nfor simplicity;\r\n* A nested transaction cannot be disconnected from its container, i.e. it must get into the container's promise chain,\r\n or it will result in an attempt to execute against an unknown connection;\r\n* As expected, a failure on any level in a nested transaction will `ROLLBACK` and `reject` the entire chain.\r\n\r\n### Transactions with SAVEPOINT\r\n\r\n`SAVEPOINT` in PostgreSQL caters for advanced transaction scenarios where partial `ROLLBACK` can be executed,\r\ndepending on the logic of the transaction.\r\n\r\nUnfortunately, this doesn't go along with the [Promises/A+] architecture that doesn't support partial `reject`.\r\n\r\nThe only work-around via promises is to strip a transaction into individual commands and execute them as a promise\r\nchain within a shared connection. The example below shows how this can be done.\r\n\r\n```javascript\r\nvar sco; // shared connection object;\r\nvar txErr; // transaction error;\r\nvar txData; // transaction data;\r\ndb.connect()\r\n    .then(function (obj) {\r\n        sco = obj; // save the connection object;\r\n        return promise.all([\r\n            sco.none('begin'),\r\n            sco.none('update users set name=$1 where id=$2', ['changed1', 1]),\r\n            sco.none('savepoint first'), // creating savepoint;\r\n            sco.none('update users set name=$1 where id=$2', ['changed2', 2]),\r\n            sco.none('rollback to first') // reverting to the savepoint;\r\n        ])\r\n            .then(function (data) {\r\n                txData = data; // save the transaction output data;\r\n                return sco.none('commit'); // persist changes;\r\n            }, function (reason) {\r\n                txErr = reason; // save the transaction failure reason;\r\n                return sco.none('rollback'); // revert changes;\r\n            });\r\n    })\r\n    .then(function () {\r\n        if (txErr) {\r\n            console.log('Rollback Reason: ' + txErr);\r\n        } else {\r\n            console.log(txData); // successful transaction output;\r\n        }\r\n    }, function (reason) {\r\n        console.log(reason); // connection issue;\r\n    })\r\n    .done(function () {\r\n        if (sco) {\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\n\r\nThe issue with stripping out a transaction like this and injecting `SAVEPOINT` - it gets much more\r\ncomplicated to control the result of individual commands within a transaction, you may need to check every\r\nresult and change the following commands accordingly. This is why it makes much more sense to do such\r\ntransactions inside SQL functions, and not in JavaScript.\r\n\r\n### Synchronous Transactions\r\n\r\nA regular transaction with a set of independent queries relies on method `batch([...])` to resolve\r\nall queries asynchronously.\r\n\r\nHowever, when it comes to executing a significant number of such queries during a bulk `INSERT` or `UPDATE`,\r\nsuch approach is no longer practical. For one thing, it implies that all requests have been\r\ncreated as promise objects, which isn't possible when dealing with a huge number if queries,\r\ndue to memory limitations imposed by NodeJS. And for another, when one query fails, the rest\r\nwill continue trying to execute, due to their promise nature, as being asynchronous. The latter\r\nwill result in many errors generated by failed queries, which by no means breaks the transaction\r\nlogic, just fills your error log with lots of query failures that are in fact of no consequence.\r\n\r\nThis is why within each transaction we have method `sequence`, to be able to execute a strict\r\nsequence of queries inside your transaction, one by one, and if one fails - the rest won't try to execute.\r\n\r\nIn the promise architecture this is achieved by using a promise factory.\r\n\r\n```javascript\r\nfunction factory(idx, t) {\r\n    // t = this;\r\n    // must create and return a promise object dynamically,\r\n    // based on the index of the sequence (parameter idx);\r\n    switch (idx) {\r\n        case 0:\r\n            return t.query(\"select 0\");\r\n        case 1:\r\n            return t.query(\"select 1\");\r\n        case 2:\r\n            return t.query(\"select 2\");\r\n    }\r\n    // returning nothing or null indicates the end of the sequence;\r\n    // throwing an error will result in a reject;\r\n}\r\n\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    return t.sequence(factory);\r\n})\r\n    .then(function (data) {\r\n        console.log(data); // print result;\r\n    }, function (reason) {\r\n        console.log(reason); // print error;\r\n    });\r\n```\r\n\r\nA simpler example, using in-line implementation and `this` context:\r\n\r\n```javascript\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    return this.sequence(function (idx) {\r\n        switch (idx) {\r\n            case 0:\r\n                return this.query(\"select 0\");\r\n            case 1:\r\n                return this.query(\"select 1\");\r\n            case 2:\r\n                return this.query(\"select 2\");\r\n        }\r\n    });\r\n})\r\n    .then(function (data) {\r\n        console.log(data); // print result;\r\n    }, function (reason) {\r\n        console.log(reason); // print error;\r\n    });\r\n```\r\n\r\nBy default, method `sequence` resolves with an array of resolved results from each\r\nquery created by the factory. However, if you have too many requests in your sequence,\r\nsuch array may quickly grow out of proportion.\r\n\r\nTo prevent this from happening, method `sequence` has been extended to the following syntax:\r\n```javascript\r\nsequence(factory, noTracking, cb);\r\n```\r\nOptional flag `noTracking` (default is `false`) can be passed to indicate that the\r\nresolved results of the sequence are not to be tracked, and the method is to resolve with just an integer -\r\ntotal number of queries that have been resolved.\r\n\r\nOptional `cb` can be passed to receive callbacks with `(idx, data)` for every query\r\nrequest that has been resolved, independent of the result tracking set by `noTracking`.\r\n\r\nParameter `noTracking` can have a significant impact on memory consumption, depending\r\non how many requests are in the sequence and the size of data they resolve with,\r\nand it should be used:\r\n* whenever the individual results from the sequence are not needed;\r\n* when executing super-massive transactions (north of 100,000 queries).\r\n\r\n#### Sequence Benchmark\r\n\r\nBelow is a benchmark conducted on a home PC, so that you know what to expect\r\nin terms of the performance.\r\n\r\nA home PC was used for the test, with the following configuration:\r\n\r\n* CPU - i7-4770K @ 4GHz, Memory - 32GB;\r\n* Windows 8.1, with PostgreSQL 9.4 on a 256GB Samsung 840 Pro.\r\n\r\nThe test was executing a single transaction with a sequence that contained 10 million inserts.\r\n[Bluebird] was used as the promise library of choice, with long-stack traces switched off.\r\n\r\nIt took 15 minutes to execute such transaction, with CPU staying at 15% load, while\r\nthe Node JS (0.12.5, 64-bit) process maintained stable at 70-75MB of overall memory usage. \r\n\r\nThis translates in nicely throttled inserts at 11,000 records a second. \r\n\r\nThe test executed `sequence` with parameter `noTracking` = `true`. And when executing the same test\r\nwithout parameter `noTracking` set, the test could barely pass 1m inserts, consuming way too much memory.\r\n\r\n**Conclusion**\r\n\r\n* The library is almost infinitely scalable when executing transactions with use of `sequence`\r\n* You should not execute a sequence larger than 100,000 queries without passing `noTracking = true` \r\n\r\n# Advanced\r\n\r\n## Initialization Options\r\n\r\nWhen initializing the library, you can pass object `options` with a set of global properties:\r\n```javascript\r\nvar options = {\r\n    // pgFormatting - redirects query formatting to PG;\r\n    // promiseLib - overrides default promise library;\r\n    // connect - database 'connect' notification;\r\n    // disconnect - database 'disconnect' notification;\r\n    // query - query execution notification;\r\n    // task - task notification;\r\n    // transact - transaction notification;\r\n    // error - error notification;\r\n    // extend - protocol extension event;\r\n    // noLocking - prevents protocol locking;\r\n};\r\nvar pgp = require('pg-promise')(options);\r\n```\r\n\r\nIf you want to get the most out the query-related events, you should use [pg-monitor].\r\n\r\n---\r\n#### pgFormatting\r\n\r\nBy default, **pg-promise** provides its own implementation of the query formatting,\r\nas explained in [Queries and Parameters](#queries-and-parameters).\r\n\r\nIf, however, you want to use query formatting that's implemented by the [PG] library, set parameter `pgFormatting`\r\nto be `true` when initializing the library, and every query formatting will redirect to the [PG]'s implementation.\r\n\r\nAlthough this has a huge implication for the library's functionality, it is not within the scope of this project to detail.\r\nFor any further reference you should use documentation of the [PG] library.\r\n\r\nNote the following formatting features implemented by [pg-promise] that are not in [node-postgres]:\r\n* Single-value formatting: [pg-promise] doesn't require use of an array when passing a single value;\r\n* [Raw-Text](https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example#raw-text) support: injecting raw/pre-formatted text values into the query;\r\n* Functions as formatting parameters, with the actual values returned from the callbacks;\r\n* [PostgreSQL Array Constructors](http://www.postgresql.org/docs/9.1/static/arrays.html#ARRAYS-INPUT) are used when formatting arrays,\r\nnot the old string syntax;\r\n* Automatic conversion of numeric `NaN`, `+Infinity` and `-Infinity` into their string presentation;\r\n\r\n**NOTE:** Formatting parameters for calling functions (methods `func` and `proc`) is not affected by this override.\r\nWhen needed, use the generic `query` instead to invoke functions with redirected query formatting.\r\n\r\n---\r\n#### promiseLib\r\n\r\nSet this property to an alternative promise library compliant with the [Promises/A+] standard.\r\n\r\nBy default, **pg-promise** uses version of [Promises/A+] provided by [Promise]. If you want to override\r\nthis and force the library to use a different implementation of the standard, just set this parameter\r\nto the library's instance.\r\n\r\nExample of switching over to [Bluebird]:\r\n```javascript\r\nvar promise = require('bluebird');\r\nvar options = {\r\n    promiseLib: promise\r\n};\r\nvar pgp = require('pg-promise')(options);\r\n```\r\n\r\nAnd if you want to use the ES6/native `Promise`, set the parameter to the main function:\r\n\r\n```javascript\r\nvar options = {\r\n    promiseLib: Promise\r\n};\r\nvar pgp = require('pg-promise')(options);\r\n```\r\nPlease note that the library makes no assumption about the level of support for the native `Promise`\r\nby your Node JS environment, expecting only that the basic `resolve` and `reject` are working in\r\naccordance with the [Promises/A+] standard.\r\n\r\n[Promises/A+] libraries that passed our compatibility test and are currently supported:\r\n\r\n* [Promise] - very solid, used by default;\r\n* [Bluebird] - best alternative all around;\r\n* [When] - quite old, not the best support;\r\n* [Q] - most widely used;\r\n* [RSVP] - doesn't have `done()`, use `finally/catch` instead\r\n* [Lie] - doesn't have `done()`. Not recommended due to poor support. \r\n* **ES6 Promise** - doesn't have `done()` or `finally()`. Not recommended, due to being slow and functionally limited (as of this writing). \r\n\r\nCompatibility with other [Promises/A+] libraries though possible, is an unknown.\r\n\r\n---\r\n#### connect\r\n\r\nGlobal notification function of acquiring a new database connection.\r\n```javascript\r\nvar options = {\r\n    connect: function(client){\r\n        var cp = client.connectionParameters;\r\n        console.log(\"Connected to database '\" + cp.database + \"'\");\r\n    }\r\n};\r\n```\r\n\r\nThe function takes only one parameter - `client` object from the [PG] library that represents connection\r\nwith the database.\r\n\r\nThe library will suppress any error thrown by the handler and write it into the console.\r\n\r\n**NOTE:** The library will throw an error instead of making the call, if `options.connect` is set to\r\na non-empty value other than a function.\r\n\r\n---\r\n#### disconnect\r\n\r\nGlobal notification function of releasing a database connection.\r\n```javascript\r\nvar options = {\r\n    disconnect: function(client){\r\n        var cp = client.connectionParameters;\r\n        console.log(\"Disconnecting from database '\" + cp.database + \"'\");\r\n    }\r\n};\r\n```\r\n\r\nThe function takes only one parameter - `client` object from the [PG] library that represents the connection\r\nthat's being released.\r\n\r\nThe library will suppress any error thrown by the handler and write it into the console.\r\n\r\n**NOTE:** The library will throw an error instead of making the call, if `options.disconnect` is set to\r\na non-empty value other than a function.\r\n\r\n---\r\n#### query\r\n\r\nGlobal notification of a query that's being executed.\r\n```javascript\r\nvar options = {\r\n    query: function (e) {\r\n        console.log(\"Query:\", e.query);\r\n        if (e.ctx) {\r\n            // this query is executing inside a task or transaction,\r\n            if (e.ctx.isTX) {\r\n                // this query is inside a transaction;\r\n            } else {\r\n                // this query is inside a task;\r\n            }\r\n\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nNotification happens just before the query execution. And if the handler throws\r\nan error, the query execution will be rejected with that error.\r\n\r\nParameter `e` is the event's context object that shares its format between events\r\n`query`, `error`, `task` and `transact`. It supports the following properties, all of which\r\nare optional:\r\n\r\n* `cn` - connection details, passed only with a connection-related `error` event.\r\n* `client` - object from the [PG] library that represents the connection;\r\n* `query` - input query string;\r\n* `params` - input query parameters;\r\n* `ctx` - task/transaction context object;\r\n\r\nA task/transaction context object (`ctx`) supports the following properties:\r\n* `isTX` - set when `ctx` is a transaction context, as opposed to just a task;\r\n* `start` - start time of the task/transaction;\r\n* `finish` - optional; finish time of the task/transaction, if it has finished;\r\n* `tag` - optional; tag object/value passed into the task/transaction, if any;\r\n* `success` - optional; indicates success for a finished task/transaction;\r\n* `result` - optional; task/transaction result, if finished: data resolved by the task/transaction,\r\n if `success` is `true`, otherwise it is set to the `reason` that was passed\r\n when rejecting the task/transaction.\r\n\r\nA task/transaction can be tagged when it is called using the following syntax:\r\n```javascript\r\n// for tasks:\r\ndb.task(tag, cb);\r\n\r\n// for transactions:\r\ndb.tx(tag, cb);\r\n// or\r\ndb.transact(tag, cb);\r\n```\r\ni.e. in front of the callback function you can inject a value or object that\r\ntags the task/transaction, so it can be used as a reference when handling events.\r\n\r\nAll properties of `ctx` marked as optional are not set, unless they are relevant\r\nto the event.\r\n\r\n**NOTE:** The library will throw an error instead of making the call, if `options.query` is set to\r\na non-empty value other than a function.\r\n\r\n---\r\n#### error\r\n\r\nGlobal notification of an error during connection, query or transaction.\r\n```javascript\r\nvar options = {\r\n    error: function (err, e) {\r\n        console.log(\"Error: \" + err);\r\n        if (e.cn) {\r\n            // this is a connection-related error;\r\n            // cn = connection details that were used.\r\n        }\r\n        if (e.query) {\r\n            console.log(\"Query:\", e.query);\r\n            if (e.params) {\r\n                console.log(\"Parameters:\", e.params);\r\n            }\r\n        }\r\n        if (e.ctx) {\r\n            // print transaction details;\r\n        }\r\n    }\r\n};\r\n```\r\nFor parameter `e` see documentation of the `query` event earlier.\r\n\r\nThe library will suppress any error thrown by the handler and write it into the console.\r\n\r\n**NOTE:** The library will throw an error instead of making the call,\r\nif `options.error` is set to a non-empty value other than a function.\r\n\r\n---\r\n#### task\r\n\r\nGlobal notification of a task start / finish events (introduced in v1.9.0).\r\n```javascript\r\nvar options = {\r\n    task: function (e) {\r\n        console.log(\"Start Time: \" + e.ctx.start);\r\n        if (e.ctx.finish) {\r\n            // this is a task `finish` event;\r\n            console.log(\"Finish Time: \" + e.ctx.finish);\r\n            if (e.ctx.success) {\r\n                // e.ctx.result = the data resolved;\r\n            } else {\r\n                // e.ctx.result = the rejection reason;\r\n            }\r\n        } else {\r\n            // this is a task `start` event;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nFor parameter `e` see documentation of the `query` event earlier.\r\n\r\nThe library will suppress any error thrown by the handler and write it into the console.\r\n\r\n---\r\n#### transact\r\n\r\nGlobal notification of a transaction start / finish events.\r\n```javascript\r\nvar options = {\r\n    transact: function (e) {\r\n        console.log(\"Start Time: \" + e.ctx.start);\r\n        if (e.ctx.finish) {\r\n            // this is a transaction `finish` event;\r\n            console.log(\"Finish Time: \" + e.ctx.finish);\r\n            if (e.ctx.success) {\r\n                // e.ctx.result = the data resolved;\r\n            } else {\r\n                // e.ctx.result = the rejection reason;\r\n            }\r\n        } else {\r\n            // this is a transaction `start` event;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nFor parameter `e` see documentation of the `query` event earlier.\r\n\r\nThe library will suppress any error thrown by the handler and write it into the console.\r\n\r\n**NOTE:** The library will throw an error instead of making the call, if `options.transact` is set to\r\na non-empty value other than a function.\r\n\r\n---\r\n#### extend\r\n\r\nOverride this event to extend the existing access layer with your own functions\r\nand properties best suited for your application.\r\n\r\nThe extension thus becomes available across all access layers:\r\n\r\n* Within the root/default database protocol;\r\n* Inside transactions, including nested ones;\r\n* Inside tasks, including nested ones.\r\n\r\nIn the example below we extend the protocol with function `addImage` that will insert\r\none binary image and resolve with the new record id:\r\n```javascript\r\nvar options = {\r\n    extend: function (obj) {\r\n        // obj = this;\r\n        obj.addImage = function (data) {\r\n            return obj.one(\"insert into images(data) values($1) returning id\",\r\n                '\\\\x' + data);\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nNOTE: All pre-defined methods and properties are read-only, so you will get an error,\r\nif you try overriding them.\r\n\r\nIt is best to extend the protocol by adding whole entity repositories to it as shown\r\nin the following example.\r\n\r\n```javascript\r\n// Users repository;\r\nfunction repUsers(obj) {\r\n    return {\r\n        add: function (name, active) {\r\n            return obj.none(\"insert into users values($1, $2)\", [name, active]);\r\n        },\r\n        delete: function (id) {\r\n            return obj.none(\"delete from users where id=$1\", id);\r\n        }\r\n    }\r\n}\r\n\r\n// Overriding 'extend' event;\r\nvar options = {\r\n    extend: function (obj) {\r\n        // obj = this;\r\n        this.users = repUsers(this);\r\n    }\r\n};\r\n\r\n// Usage example:\r\ndb.users.add(\"John\", true)\r\n    .then(function () {\r\n        // user added successfully;\r\n    }, function (reason) {\r\n        // error occurred;\r\n    });\r\n```\r\n\r\nThe library will suppress any error thrown by the handler and write it into the console.\r\n\r\n**NOTE:** The library will throw an error instead of making the call, if `options.extend` is set to\r\na non-empty value other than a function.\r\n\r\n---\r\n#### noLocking\r\n\r\nBy default, the library locks its protocol to read-only access, as a fool-proof mechanism.\r\nSpecifically for the `extend` event this serves as a protection against overriding existing\r\nproperties or trying to set them at the wrong time. \r\n   \r\nIf this provision gets in the way of using a mock-up framework for your tests, you can force\r\nthe library to deactivate most of the locks by setting `noLocking=true` within the options.\r\n\r\n## Library de-initialization\r\n\r\nWhen exiting your application, you can make the following call:\r\n```javascript\r\npgp.end();\r\n```\r\nThis will release [pg] connection pool globally and make sure that the process terminates without any delay.\r\nIf you do not call it, your process may be waiting for 30 seconds (default for [poolIdleTimeout](https://github.com/brianc/node-postgres/blob/master/lib/defaults.js#L31)),\r\nwaiting for the connection to expire in the pool.\r\n\r\nIf, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\r\n\r\n# History\r\n\r\n* Version 1.11.0 added [noLocking](#nolocking) initialization option. Released: September 30, 2015.\r\n* Version 1.10.3 added enforced locks on every level of the library. Released: September 11, 2015.\r\n* Version 1.10.0 added support for `batch` execution within tasks and transactions. Released: September 10, 2015.\r\n* Version 1.9.5 added support for [Raw Custom Types](#raw-custom-types). Released: August 30, 2015.\r\n* Version 1.9.3 added support for [Custom Type Formatting](#custom-type-formatting). Released: August 30, 2015.\r\n* Version 1.9.0 added support for [Tasks](#tasks) + initial [jsDoc](https://github.com/jsdoc3/jsdoc) support. Released: August 21, 2015.\r\n* Version 1.8.2 added support for [Prepared Statements](https://github.com/brianc/node-postgres/wiki/Prepared-Statements). Released: August 01, 2015.\r\n* Version 1.8.0 added support for Query Streaming via [node-pg-query-stream](https://github.com/brianc/node-pg-query-stream). Released: July 23, 2015.\r\n* Version 1.7.2 significant code refactoring and optimizations; added support for super-massive transactions. Released: June 27, 2015.\r\n* Version 1.6.0 major update for the test platform + adding coverage. Released: June 19, 2015.\r\n* Version 1.5.0 major changes in architecture and query formatting. Released: June 14, 2015.\r\n* Version 1.4.0 added `this` context to all callbacks where applicable. Released: May 31, 2015.\r\n* Version 1.3.1 extended [Named Parameters](#named-parameters) syntax to support `{}`,`()`,`[]`,`<>` and `//`. Released: May 24, 2015.\r\n* Version 1.3.0 much improved error handling and reporting. Released: May 23, 2015.\r\n* Version 1.2.0 extended [Named Parameters](#named-parameters) syntax with `$(varName)`. Released: May 16, 2015.\r\n* Version 1.1.0 added support for functions as parameters. Released: April 3, 2015.\r\n* Version 1.0.5 added strict query sequencing for transactions. Released: April 26, 2015.\r\n* Version 1.0.3 added method `queryRaw(query, values)`. Released: April 19, 2015.\r\n* Version 1.0.1 improved error reporting for queries. Released: April 18, 2015.\r\n* Version 1.0.0 official release milestone. Released: April 17, 2015.\r\n* Version 0.9.8 added native json support, extended numeric support for `NaN`, `+Infinity` and `-Infinity`. Released: April 16, 2015.\r\n* Version 0.9.7 received support for protocol extensibility. Released: April 15, 2015.\r\n* Version 0.9.5 received support for raw-text variables. Released: April 12, 2015.\r\n* Version 0.9.2 received support for PostgreSQL Array Types. Released: April 8, 2015.\r\n* Version 0.9.0 changed the notification protocol. Released: April 7, 2015.\r\n* Version 0.8.4 added support for error notifications. Released: April 6, 2015.\r\n* Version 0.8.0 added support for named-parameter formatting. Released: April 3, 2015.\r\n* Version 0.7.0 fixes the way `as.format` works (breaking change). Released: April 2, 2015.\r\n* Version 0.6.2 has good database test coverage. Released: March 28, 2015.\r\n* Version 0.5.6 introduces support for nested transaction. Released: March 22, 2015.\r\n* Version 0.5.3 - minor changes; March 14, 2015.\r\n* Version 0.5.1 included wider support for alternative promise libraries. Released: March 12, 2015.\r\n* Version 0.5.0 introduces many new features and fixes, such as properties **pgFormatting** and **promiseLib**. Released on March 11, 2015.\r\n* Version 0.4.9 represents a solid code base, backed up by comprehensive testing. Released on March 10, 2015.\r\n* Version 0.4.0 is a complete rewrite of most of the library, made first available on March 8, 2015.\r\n* Version 0.2.0 introduced on March 6th, 2015, supporting multiple databases.\r\n* A refined version 0.1.4 released on March 5th, 2015.\r\n* First solid Beta, 0.1.2 on March 4th, 2015.\r\n* It reached first Beta version 0.1.0 on March 4th, 2015.\r\n* The first draft v0.0.1 was published on March 3rd, 2015, and then rapidly incremented due to many initial changes that had to come in, mostly documentation.\r\n\r\n# License\r\n\r\nCopyright (c) 2015 Vitaly Tomilov (vitaly.tomilov@gmail.com)\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\nDEALINGS IN THE SOFTWARE.\r\n\r\n[API]:https://github.com/vitaly-t/pg-promise/blob/master/API.md\r\n[pg-monitor]:https://github.com/vitaly-t/pg-monitor\r\n[pg-promise]:https://github.com/vitaly-t/pg-promise\r\n[PG]:https://github.com/brianc/node-postgres\r\n[pg]:https://github.com/brianc/node-postgres\r\n[node-postgres]:https://github.com/brianc/node-postgres\r\n[Promises/A+]:https://promisesaplus.com/\r\n[Promise]:https://github.com/then/promise\r\n[Bluebird]:https://github.com/petkaantonov/bluebird\r\n[When]:https://github.com/cujojs/when\r\n[Q]:https://github.com/kriskowal/q\r\n[RSVP]:https://github.com/tildeio/rsvp.js\r\n[Lie]:https://github.com/calvinmetcalf/lie\r\n",
  "readmeFilename": "README.md",
  "_id": "pg-promise@1.11.0",
  "dist": {
    "shasum": "a343ab1fd8c82b704408ebf26c6b9e6444acb84e"
  },
  "_from": "pg-promise@",
  "_resolved": "https://registry.npmjs.org/pg-promise/-/pg-promise-1.11.0.tgz"
}
